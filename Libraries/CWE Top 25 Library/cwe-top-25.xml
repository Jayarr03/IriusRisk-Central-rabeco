<?xml version="1.0" encoding="UTF-8"?>
<library ref="CWE-Top-25" name="CWE Top 25" enabled="true" revision="1" tags="">
  <desc/>
  <categoryComponents/>
  <componentDefinitions/>
  <supportedStandards/>
  <riskPatterns>
    <riskPattern uuid="c29a23fa-daa4-46a4-bc20-d5417eb44d24" ref="CodeExecution" name="Code Execution" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="325dc5c9-18be-459a-9fa5-e42a4086b03d" ref="CWE-119" name="Improper Restriction of Operations within the Bounds of a Memory Buffer" state="0" impact="50">
          <desc>The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.
Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data. As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.</desc>
          <test uuid="353a2fd3-c836-4549-b9b5-d2abc5371112" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="e5f695cf-6a42-4ea7-a0f9-bea1f0c03860" ref="CWE-77" name="Improper Neutralization of Special Elements used in a Command ('Command Injection')" state="0" impact="50">
          <desc>The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.
Command injection vulnerabilities typically occur when: 1. Data enters the application from an untrusted source. 2. The data is part of a string that is executed as a command by the application. 3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. Many protocols and products have their own custom command language. While OS or shell command strings are frequently discovered and targeted, developers may not realize that these other command languages might also be vulnerable to attacks. Command injection is a common problem with wrapper programs.</desc>
          <test uuid="4433195d-c4c3-4617-b2d4-ef9296dcc0bd" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="b439eb47-f347-4d59-a897-23ab55228d68" ref="CWE-78" name="Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" state="0" impact="50">
          <desc>The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.
This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(nslookup [HOSTNAME]) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use exec([COMMAND]) to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.</desc>
          <test uuid="309a35d5-0b20-47c6-989d-15bbf5a75df5" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="57a41608-f762-4929-8670-91bbbbed3a7a" ref="CWE-94" name="Improper Control of Generation of Code ('Code Injection')" state="0" impact="50">
          <desc>The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.
When a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution. Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.</desc>
          <test uuid="38be809b-9dbc-4d25-9c6e-effcd0683284" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="74ed0296-1d35-4d84-b848-eb72d56d4dcd" ref="Detection_Methods" name="CWE-77 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="3257ab3b-394a-434f-b07f-d17af75cdc3e" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="b074ec5f-b54f-49de-ae7d-742bcc628b1f" ref="Potential_Mitigations" name="CWE-77 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :If at all possible, use library calls rather than external processes to recreate the desired functionality.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :If possible, ensure that all external commands called from the program are statically created.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Operation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Run time: Run time policy enforcement may be used in an allowlist fashion to prevent use of any non-sanctioned commands.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :System Configuration // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assign permissions that prevent the user from accessing/opening privileged files.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="ab150bf8-e79a-4f84-b585-eb1a56d2fbe5" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="4479c7a4-3fac-47c4-85b0-3de5e3c8405f" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="d34f5d89-1180-4bea-a0fe-f572f7ef5e2c" ref="Buffer-Overflow-Attacks" name="CWE-119 Buffer Overflow Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit buffer overflow vulnerabilities to overwrite adjacent memory locations, potentially leading to arbitrary code execution, denial of service, or system compromise&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // IMPACT:Modify Memory // NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Memory // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:DoS: Resource Consumption (CPU) // IMPACT:DoS: Resource Consumption (Memory) // NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Memory // NOTE:In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-119">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="49bc9c34-aa25-4e07-ba89-628d68d8c864" ref="Code-Injection-Attacks" name="CWE-94 Code Injection Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious code into the application, potentially leading to arbitrary code execution, data theft, or unauthorized access to resources&lt;br&gt;&lt;br&gt;SCOPE:Access Control // IMPACT:Bypass Protection Mechanism // NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.&lt;br&gt;SCOPE:Access Control // IMPACT:Gain Privileges or Assume Identity // NOTE:Injected code can access resources that the attacker is directly prevented from accessing.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.&lt;br&gt;SCOPE:Non-Repudiation // IMPACT:Hide Activities // NOTE:Often the actions performed by injected control code are unlogged.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-94">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="e98fe400-33a2-4522-8c86-8aee6138fad5" ref="Command-Injection-Attacks" name="CWE-77 Command Injection Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious commands into system commands executed by the application, leading to unauthorized access, data leakage, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:If a malicious user injects a character (such as a semi-colon) that delimits the end of one command and the beginning of another, it may be possible to then insert an entirely new and unrelated command that was not intended to be executed.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-77">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="fc425959-1aa2-4c7c-b621-98f5e9bd6f35" ref="Operating-System-Command-Injection" name="CWE-78 Operating System Command Injection" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious commands into operating system commands executed by the application, allowing them to execute arbitrary commands on the underlying operating system with the privileges of the application.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Non-Repudiation // IMPACT:Execute Unauthorized Code or Commands // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:Read Files or Directories // IMPACT:Modify Files or Directories // IMPACT:Read Application Data // IMPACT:Modify Application Data // IMPACT:Hide Activities // NOTE:Attackers could execute unauthorized commands, which could then be used to disable the product, or read and modify data for which the attacker does not have permissions to access directly. Since the targeted application is directly executing the commands instead of the attacker, any malicious activities may appear to come from the application or the application's owner.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-78">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="4be2798e-4034-4a98-ac26-2164569634c7" ref="ConfigurationChange" name="Configuration Change" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="071b2233-7865-4dd3-97cc-3ac4da23d1a3" ref="CWE-190" name="Integer Overflow or Wraparound" state="0" impact="50">
          <desc>The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.
An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.</desc>
          <test uuid="083babfc-4e47-41ec-a9a4-d5af7848afbc" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="646e2bba-f0e4-4d89-940a-11364b3ec495" ref="Detection_Methods" name="CWE-190 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Black Box // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Sometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Manual Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Architecture or Design Review // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="2f75331b-8176-4a04-a672-228c4ac5d306" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="85c7922c-5034-4ecd-85af-c93eff097065" ref="Potential_Mitigations" name="CWE-190 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Requirements // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Requirements // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Language Selection // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. If possible, choose a language or compiler that performs automatic bounds checking.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Libraries or Frameworks // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, not-a-number calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Compilation or Build Hardening // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="b9e460b4-2462-4f3d-9b30-eb1a7ed5a013" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="dd9f57cc-8c54-4cd3-b640-2111bb57aee1" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="2e6860b7-b7bc-4cc1-8631-08cb7f5ef6a2" ref="Arithmetic-Errors" name="CWE-190 Arithmetic Errors" state="Expose" source="MANUAL" library="">
              <desc>Attackers could manipulate integer variables to cause unexpected behavior, potentially leading to system crashes, denial of service, or security vulnerabilities such as buffer overflows or code execution.&lt;br&gt;&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:DoS: Resource Consumption (CPU) // IMPACT:DoS: Resource Consumption (Memory) // IMPACT:DoS: Instability // NOTE:This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high.&lt;br&gt;SCOPE:Integrity // IMPACT:Modify Memory // NOTE:If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur.&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Access Control // IMPACT:Execute Unauthorized Code or Commands // IMPACT:Bypass Protection Mechanism // NOTE:This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-190">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="a0c23ec9-3977-4b29-87d6-bb9b2309d270" ref="DataStorage" name="Data Storage" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="58e87658-a781-462c-b7d1-6df4b39a6d81" ref="CWE-125" name="Out-of-bounds Read" state="0" impact="50">
          <desc>The product reads data past the end, or before the beginning, of the intended buffer.
Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.</desc>
          <test uuid="4253a7f6-5b06-4f94-9ce5-172392b5a5c5" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="2e29b5c0-a07e-433e-b739-b631920cb602" ref="CWE-798" name="Use of Hard-coded Credentials" state="0" impact="50">
          <desc>The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.
Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.</desc>
          <test uuid="b7efdf25-2a3a-4777-851a-08ff18d4d55d" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="e615931f-b8ae-4f4a-81d6-49be83c0846d" ref="Detection_Methods" name="CWE-125 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Fuzzing // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="426863e9-bdad-42e2-940b-7511fd39cedd" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="02c3cb82-8221-401c-8e42-fa4f2956a57d" ref="Potential_Mitigations" name="CWE-125 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Language Selection // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a language that provides appropriate memory abstractions.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="6ad9a86e-4500-4b23-a89e-5bb4847ece4b" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="e27e48bb-55c1-4679-bfae-fa01ae8a7bfc" ref="Information-Disclosure" name="Information Disclosure" desc="" library="">
          <threats>
            <threat uuid="abf58260-b953-4637-b58f-e935f89e4c09" ref="Credential-Exposure" name="CWE-798 Credential Exposure" state="Expose" source="MANUAL" library="">
              <desc>Attackers could extract hard-coded credentials from the application's source code or binaries, potentially leading to unauthorized access to systems or sensitive data.&lt;br&gt;&lt;br&gt;SCOPE:Access Control // IMPACT:Bypass Protection Mechanism // NOTE:If hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Access Control&lt;br&gt;SCOPE:Other // IMPACT:Read Application Data // IMPACT:Gain Privileges or Assume Identity // IMPACT:Execute Unauthorized Code or Commands // IMPACT:Other // NOTE:This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-798">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="d50f8474-2198-48ac-958b-bbceb1f2135f" ref="Information-Disclosure-" name="CWE-125 Information Disclosure " state="Expose" source="MANUAL" library="">
              <desc>Attackers could read sensitive data from memory locations beyond the boundaries of an array or buffer, potentially exposing sensitive information such as passwords or cryptographic keys.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Memory&lt;br&gt;SCOPE:Confidentiality // IMPACT:Bypass Protection Mechanism // NOTE:By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-125">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="e204dbf1-ee9b-426d-9c10-e36ea551c136" ref="Database" name="Database" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="d392fefa-5992-4637-aadf-aff3b3351297" ref="CWE-20" name="Improper Input Validation" state="0" impact="50">
          <desc>The product receives input or data, but it does not validate or incorrectly validates that the input has the properties that are required to process the data safely and correctly.
Input validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution. Input validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.) Input validation can be applied to: raw data - strings, numbers, parameters, file contents, etc. metadata - information about the raw data, such as headers or size Data can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data. Many properties of raw data or metadata may need to be validated upon entry into the code, such as: specified quantities such as size, length, frequency, price, rate, number of operations, time, etc. implied or derived quantities, such as the actual size of a file instead of a specified size indexes, offsets, or positions into more complex data structures symbolic keys or other elements into hash tables, associative arrays, etc. well-formedness, i.e. syntactic correctness - compliance with expected syntax lexical token correctness - compliance with rules for what is treated as a token specified or derived type - the actual type of the input (or what the input appears to be) consistency - between individual data elements, between raw data and metadata, between references, etc. conformance to domain-specific rules, e.g. business logic equivalence - ensuring that equivalent inputs are treated the same authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data Implied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. Note that input validation has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation. Finally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name O'Reilly would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.</desc>
          <test uuid="823ee8cd-41d3-45a7-b66d-00b714088744" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="031ff44b-e72d-44ba-8c3f-9beff5dba9e1" ref="CWE-89" name="Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" state="0" impact="50">
          <desc>The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.
Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or product package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.</desc>
          <test uuid="e8c33b8c-693c-44fb-805a-8fbdd649c8c2" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="9b5fd377-b2de-4cb3-8373-a50bc66a2e4a" ref="Detection_Methods" name="CWE-20 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Some instances of improper input validation can be detected using automated static analysis. A static analysis tool might allow the user to specify which application-specific methods or functions perform input validation; the tool might also have built-in knowledge of validation frameworks such as Struts. The tool may then suppress or de-prioritize any associated warnings. This allows the analyst to focus on areas of the software in which input validation does not appear to be present. Except in the cases described in the previous paragraph, automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When custom input validation is required, such as when enforcing business rules, manual analysis is necessary to ensure that the validation is properly implemented.&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Fuzzing // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Fuzzing techniques can be useful for detecting input validation errors. When unexpected inputs are provided to the software, the software should not crash or otherwise become unstable, and it should generate application-controlled error messages. If exceptions or interpreter-generated error messages occur, this indicates that the input was not detected and handled within the application logic itself.&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities &amp; anomalies // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Automated Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Manual Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer Cost effective for partial coverage: Host Application Interface Scanner Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Architecture or Design Review // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="cda6345c-2726-47d2-b453-5d5e8f97dd73" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="543821f1-7ac5-433e-8f4b-e11e1be7587f" ref="Potential_Mitigations" name="CWE-20 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Attack Surface Reduction // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build recognizers for that language. This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Libraries or Frameworks // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Attack Surface Reduction // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="6f3247bb-1cfd-4554-b4b7-ce14b1aaa5c3" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="de16809a-b241-4f14-95cc-600818c180ac" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="7c0e1aea-bde5-4f00-a36d-f5a55cebe56e" ref="Data-Injection-Attacks" name="CWE-20 Data Injection Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious code or unexpected data into the application, leading to various security vulnerabilities such as SQL injection, cross-site scripting (XSS), or command injection.&lt;br&gt;&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:DoS: Resource Consumption (CPU) // IMPACT:DoS: Resource Consumption (Memory) // NOTE:An attacker could provide unexpected values and cause a program crash or excessive consumption of resources, such as memory and CPU.&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Memory // IMPACT:Read Files or Directories // NOTE:An attacker could read confidential data if they are able to control resource references.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Modify Memory // IMPACT:Execute Unauthorized Code or Commands // NOTE:An attacker could use malicious input to modify data or possibly alter control flow in unexpected ways, including arbitrary command execution.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-20">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="d1070cf8-0ec3-4f6d-84c5-a377bb2b1532" ref="SQL-Injection-Attacks" name="CWE-89 SQL Injection Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious SQL queries into input fields, potentially allowing them to access, modify, or delete data from the application's database, or execute arbitrary SQL commands.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Application Data // NOTE:Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.&lt;br&gt;SCOPE:Access Control // IMPACT:Bypass Protection Mechanism // NOTE:If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.&lt;br&gt;SCOPE:Access Control // IMPACT:Bypass Protection Mechanism // NOTE:If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.&lt;br&gt;SCOPE:Integrity // IMPACT:Modify Application Data // NOTE:Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-89">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="c8b30828-e60c-4828-8c83-7ae06dccaf4a" ref="FileSystem" name="File System" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="90823309-66e1-4304-81da-90e4bfd544a3" ref="CWE-22" name="Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')" state="0" impact="50">
          <desc>The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.
Many file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the product may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.</desc>
          <test uuid="8742463f-c482-4f99-86e5-fb74310dec5c" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="7104eedf-ca25-47da-9709-706a8391b53b" ref="CWE-434" name="Unrestricted Upload of File with Dangerous Type" state="0" impact="50">
          <desc>The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.
nan</desc>
          <test uuid="1a16109a-aa90-4d55-a218-1cd0c7c7c422" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="00283eef-7738-4773-b94f-c5237a85b50c" ref="Detection_Methods" name="CWE-22 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Automated techniques can find areas where path traversal weaknesses exist. However, tuning or customization may be required to remove or de-prioritize path-traversal problems that are only exploitable by the product's administrator - or other privileged users - and thus potentially valid behavior or, at worst, a bug instead of a vulnerability. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all file access operations can be assessed within limited time constraints. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities &amp; anomalies // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Automated Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Manual Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Architecture or Design Review // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="18263641-0257-41ce-a827-2f208ff7cae3" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="5dd1ce12-8bd4-4c44-970a-a76eee0ce03e" ref="Potential_Mitigations" name="CWE-22 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in Perl realpath() in PHP&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Libraries or Frameworks // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Firewall // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Environment Hardening // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Enforcement by Conversion // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Sandbox or Jail // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Limited&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Attack Surface Reduction // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Operation Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Environment Hardening // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="d8bbc5e9-982d-4acd-be25-dd38639373e0" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="f44ed0e7-d937-4d04-922c-481433f12611" ref="Information-Disclosure" name="Information Disclosure" desc="" library="">
          <threats>
            <threat uuid="193a4c84-4e3a-4b5e-826f-41e9310ceb17" ref="Directory-Traversal-Attacks" name="CWE-22 Directory Traversal Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could manipulate file paths to access files and directories outside of the intended directory, potentially exposing sensitive information or executing unauthorized actions on the system.&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:The attacker may be able to create or overwrite critical files that are used to execute code, such as programs or libraries.&lt;br&gt;SCOPE:Integrity // IMPACT:Modify Files or Directories // NOTE:The attacker may be able to overwrite or create critical files, such as programs, libraries, or important data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, appending a new account at the end of a password file may allow an attacker to bypass authentication.&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Files or Directories // NOTE:The attacker may be able read the contents of unexpected files and expose sensitive data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, by reading a password file, the attacker could conduct brute force password guessing attacks in order to break into an account on the system.&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // NOTE:The attacker may be able to overwrite, delete, or corrupt unexpected critical files such as programs, libraries, or important data. This may prevent the product from working at all and in the case of a protection mechanisms such as authentication, it has the potential to lockout every user of the product.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-22">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
        <usecase uuid="274c910b-86d2-4182-8023-2f4bd103430c" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="ed30b5f7-26e8-4dfb-a241-cff5bfdc7cf8" ref="File-Upload-Vulnerabilities" name="CWE-434 File Upload Vulnerabilities" state="Expose" source="MANUAL" library="">
              <desc>Attackers could upload malicious files disguised as harmless ones, potentially leading to arbitrary code execution, data breaches, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:Arbitrary code execution is possible if an uploaded file is interpreted and executed as code by the recipient. This is especially true for .asp and .php extensions uploaded to web servers because these file types are often treated as automatically executable, even when file system permissions do not specify execution. For example, in Unix environments, programs typically cannot run unless the execute bit is set, but PHP programs may be executed by the web server without directly invoking them on the operating system.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-434">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="1fdda4b5-12a2-4671-bc73-f9b8cc9d83b5" ref="Objects" name="Objects" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="079617d0-308d-48a9-bc91-f4b3af2121c4" ref="CWE-416" name="Use After Free" state="0" impact="50">
          <desc>Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.
The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.</desc>
          <test uuid="c1af2fba-3868-4323-8c97-29f44f286fe0" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="d0edfaee-3dad-46aa-9ebb-e0b760c8d728" ref="CWE-476" name="NULL Pointer Dereference" state="0" impact="50">
          <desc>A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.
NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.</desc>
          <test uuid="b5cd56b9-db22-4f09-a7b1-62d2b0abee7e" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="6f6dcf9a-1c4e-4dbd-a46a-e41f7e8311c5" ref="CWE-502" name="Deserialization of Untrusted Data" state="0" impact="50">
          <desc>The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.
It is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption. Data that is untrusted can not be trusted to be well-formed. When developers place no restrictions on gadget chains, or series of instances and method invocations that can self-execute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.</desc>
          <test uuid="0f66f3d8-f729-4063-8736-02d317181193" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="872f1fc8-0b97-4a4a-ade2-16edb6170366" ref="CWE-787" name="Out-of-bounds Write" state="0" impact="50">
          <desc>The product writes data past the end, or before the beginning, of the intended buffer.
Typically, this can result in corruption of data, a crash, or code execution. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent write operation then produces undefined or unexpected results.</desc>
          <test uuid="81f9b1af-6496-47cd-91b3-b8f2b5843b97" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="a1b0bde9-f7a6-470c-8852-814c7ff2a7dc" ref="Detection_Methods" name="CWE-416 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Fuzzing // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="aef73b96-d8d2-4c43-934b-0b6df081e5d9" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="b6f5ccbf-4734-418d-aea5-c30c64d12b1b" ref="Potential_Mitigations" name="CWE-416 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Choose a language that provides automatic memory management.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="a150ed09-e36e-4f8c-b8c8-29eb734ffaed" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="ad2924d7-535f-470a-ae9e-6e0cb38694ff" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="e624eb56-2702-450b-aa3f-536997565b45" ref="Deserialization-Attacks" name="CWE-502 Deserialization Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could manipulate serialized objects to execute arbitrary code, potentially leading to remote code execution, data breaches, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Integrity // IMPACT:Modify Application Data // IMPACT:Unexpected State // NOTE:Attackers can modify unexpected objects or data that was assumed to be safe from modification.&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Resource Consumption (CPU) // NOTE:If a function is making an assumption on when to terminate, based on a sentry in a string, it could easily never terminate.&lt;br&gt;SCOPE:Other // IMPACT:Varies by Context // NOTE:The consequences can vary widely, because it depends on which objects or methods are being deserialized, and how they are used. Making an assumption that the code in the deserialized object is valid is dangerous and can enable exploitation.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-502">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="13d4011c-2232-46ff-8f1e-8544208fd9c6" ref="Memory-Corruption" name="CWE-416 Memory Corruption" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit use-after-free vulnerabilities to manipulate memory after it has been freed, potentially leading to arbitrary code execution, denial of service, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Integrity // IMPACT:Modify Memory // NOTE:The use of previously freed memory may corrupt valid data, if the memory area in question has been allocated and used properly elsewhere.&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // NOTE:If chunk consolidation occurs after the use of previously freed data, the process may crash when invalid data is used as chunk information.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:If malicious data is entered before chunk consolidation can take place, it may be possible to take advantage of a write-what-where primitive to execute arbitrary code.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-416">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="55d7bc2f-75d8-4805-979f-766188e1aef1" ref="Memory-Corruption-" name="CWE-787 Memory Corruption " state="Expose" source="MANUAL" library="">
              <desc>Attackers could write data beyond the boundaries of allocated memory, potentially leading to arbitrary code execution, denial of service, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Availability // IMPACT:Modify Memory // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:Execute Unauthorized Code or Commands&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-787">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="64e9676e-0dda-4827-a4fb-bb92da1ca57a" ref="Null-Pointer-Dereference" name="CWE-476 Null Pointer Dereference" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit null pointer dereference vulnerabilities to cause a program to crash or execute arbitrary code, potentially leading to denial of service or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // NOTE:NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // IMPACT:Read Memory // IMPACT:Modify Memory // NOTE:In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-476">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="d038d9cf-ff0d-48c9-9f65-1cbe4ff28d7f" ref="SharedResource" name="Shared Resource" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="a51064b8-70a6-48a0-bebd-cb6d28127ecf" ref="CWE-362" name="Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" state="0" impact="50">
          <desc>The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.
This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an interfering code sequence can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single x++ statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x). The interfering code sequence could be trusted or untrusted. A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.</desc>
          <test uuid="7c018ea2-f30b-4556-b85b-6d506963cec2" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="cc03f776-8e36-47cf-bfe3-0145b1d7b44c" ref="Detection_Methods" name="CWE-362 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Black Box // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable.&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: White Box // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609).&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Dynamic Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Binary or Bytecode // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Automated Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: SOAR Partial&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Dynamic Analysis with Manual Results Interpretation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Framework-based Fuzzer Cost effective for partial coverage: Fuzz Tester Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Manual Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis - Source Code // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Architecture or Design Review // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="cef1c105-bcc8-4060-b525-10d2bf8a55b0" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="46061232-3ef5-4652-8161-575c6d562256" ref="Potential_Mitigations" name="CWE-362 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use thread-safe capabilities such as the data access abstraction in Spring.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When using multithreading and operating on shared variables, only use thread-safe functions.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use atomic operations on shared variables. Be wary of innocent-looking constructs such as x++. This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Environment Hardening // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="91a4ec64-becb-482a-bfe9-023e22c35859" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="131c2f5e-3a03-494b-afde-dee2dae0d745" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="38516ff3-719f-4a38-82d7-80dca9e8ceb1" ref="Race-Condition-Attacks" name="CWE-362 Race Condition Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit race conditions to manipulate shared resources in unexpected ways, potentially leading to data corruption, denial of service, or security vulnerabilities.&lt;br&gt;&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Resource Consumption (CPU) // IMPACT:DoS: Resource Consumption (Memory) // IMPACT:DoS: Resource Consumption (Other) // NOTE:When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion (CWE-400).&lt;br&gt;SCOPE:Availability // IMPACT:DoS: Crash, Exit, or Restart // IMPACT:DoS: Instability // NOTE:When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash.&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Integrity // IMPACT:Read Files or Directories // IMPACT:Read Application Data // NOTE:When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59).&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-362">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="e060ff35-1f79-4063-a08f-aa330dcb3b75" ref="UserAccess" name="User Access" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="2b9b1a4f-5bd6-4b06-8d12-96d2ea890204" ref="CWE-269" name="Improper Privilege Management" state="0" impact="50">
          <desc>The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.
nan</desc>
          <test uuid="3ebbe7f8-76cf-4f10-846d-53f85e74fbea" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="3bd81e1f-6910-4d7c-b81d-ec3c7bdb5900" ref="CWE-276" name="Incorrect Default Permissions" state="0" impact="50">
          <desc>During installation, installed file permissions are set to allow anyone to modify those files.
nan</desc>
          <test uuid="daad5bfd-c108-4d0b-a81f-0cecb44141f3" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="cf9ccb4a-d362-4583-8ec4-bbbc233a4d1b" ref="CWE-287" name="Improper Authentication" state="0" impact="50">
          <desc>When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.
nan</desc>
          <test uuid="8dc43810-ba3a-4c48-876c-f4d6fc12e14b" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="d3daba4d-572f-4dfb-9ed7-757c0165715c" ref="CWE-306" name="Missing Authentication for Critical Function" state="0" impact="50">
          <desc>The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.
As data is migrated to the cloud, if access does not require authentication, it can be easier for attackers to access the data from anywhere on the Internet.</desc>
          <test uuid="c293175c-488a-40dc-904c-86127926a701" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="063a3dca-047d-4503-94e8-afea319484b8" ref="CWE-862" name="Missing Authorization" state="0" impact="50">
          <desc>The product does not perform an authorization check when an actor attempts to access a resource or perform an action.
Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource. When access control checks are not applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.</desc>
          <test uuid="a01dc7de-f835-4114-9b59-cec1086ed1da" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="f49543d5-50b6-4e77-8024-e55439ea9582" ref="CWE-863" name="Incorrect Authorization" state="0" impact="50">
          <desc>The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.
Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource. When access control checks are incorrectly applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.</desc>
          <test uuid="48624ef2-b9ab-4b50-bec3-35988be8fc4b" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="6c870ad9-24a9-4ce2-8ada-a82dad48ce83" ref="Detection_Methods" name="CWE-269 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.) // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: High::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="c3607be1-386e-46b3-9eac-765f33476cd8" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="bb779e35-0fe8-414e-a34c-1e6cf8de4f15" ref="Potential_Mitigations" name="CWE-269 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Operation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Separation of Privilege // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Follow the principle of least privilege when assigning access rights to entities in a software system.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Separation of Privilege // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="c0d6f388-e5ef-4a5c-9295-6afc2da48422" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="f246b3fd-7057-4c33-9ece-691f0ce63759" ref="Elevation-of-Privilege" name="Elevation of Privilege" desc="" library="">
          <threats>
            <threat uuid="a7292a3d-28cc-4b5a-8853-501bef2c9e9a" ref="Privilege-Escalation" name="CWE-269 Privilege Escalation" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit weaknesses in privilege management to gain unauthorized access to resources or execute privileged actions beyond their intended permissions.&lt;br&gt;&lt;br&gt;SCOPE:Access Control // IMPACT:Gain Privileges or Assume Identity&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-269">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
                <weakness ref="CWE-863">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
        <usecase uuid="2fb61a15-1ae9-4f41-9302-af4113eb0cfd" ref="Spoofing" name="Spoofing" desc="" library="">
          <threats>
            <threat uuid="bc7a6fc6-4231-4aa2-b179-cdc888fec881" ref="Authentication-Bypass" name="CWE-287 Authentication Bypass" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit weaknesses in the authentication mechanism to gain unauthorized access to the application or its resources, potentially leading to data breaches or unauthorized actions.&lt;br&gt;&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Access Control // IMPACT:Read Application Data // IMPACT:Gain Privileges or Assume Identity // IMPACT:Execute Unauthorized Code or Commands // NOTE:This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-287">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="71b1eea0-728e-4e9c-ab61-31f88cc10e1f" ref="Unauthenticated-Access-to-Critical-Functions-" name="CWE-306 Unauthenticated Access to Critical Functions " state="Expose" source="MANUAL" library="">
              <desc>Attackers could access critical functions or sensitive data without proper authentication, potentially leading to unauthorized actions or data breaches.&lt;br&gt;&lt;br&gt;SCOPE:Access Control&lt;br&gt;SCOPE:Other // IMPACT:Gain Privileges or Assume Identity // IMPACT:Other // NOTE:Exposing critical functionality essentially provides an attacker with the privilege level of that functionality. The consequences will depend on the associated functionality, but they can range from reading or modifying sensitive data, access to administrative or other privileged functionality, or possibly even execution of arbitrary code.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-306">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="985594a3-6dc4-44dc-836f-270d73d4dbb8" ref="Unauthorized-Access" name="CWE-276 Unauthorized Access" state="Expose" source="MANUAL" library="">
              <desc>Attackers could exploit overly permissive default permissions to access sensitive files, directories, or system resources, potentially leading to data breaches or unauthorized modifications.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Integrity // IMPACT:Read Application Data // IMPACT:Modify Application Data&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-276">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
                <weakness ref="CWE-862">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
    <riskPattern uuid="d48b6ef4-a11f-4815-b406-ff954325dcd7" ref="WebApplication" name="Web Application" desc="">
      <tags/>
      <weaknesses>
        <weakness uuid="38fee7cb-fa1b-416b-800d-28678bcaebff" ref="CWE-352" name="Cross-Site Request Forgery (CSRF)" state="0" impact="50">
          <desc>The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.
When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.</desc>
          <test uuid="25a33fc6-0325-4907-989f-b7c70b252742" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="ab196292-a221-4274-ac6b-6c2d66d54444" ref="CWE-79" name="Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" state="0" impact="50">
          <desc>The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.
Cross-site scripting (XSS) vulnerabilities occur when: Untrusted data enters a web application, typically from a web request. The web application dynamically generates a web page that contains this untrusted data. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain. There are three main kinds of XSS: Type 1: Reflected XSS (or Non-Persistent) - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser. Type 2: Stored XSS (or Persistent) - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. Type 0: DOM-Based XSS - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as drive-by hacking. In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.</desc>
          <test uuid="3b2c0ff7-84ca-4729-9b78-e0f447e7c225" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
        <weakness uuid="ccb9bdb7-9e9a-4fe3-b984-0d138a35a9fa" ref="CWE-918" name="Server-Side Request Forgery (SSRF)" state="0" impact="50">
          <desc>The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.
By providing URLs to unexpected hosts or ports, attackers can make it appear that the server is sending the request, possibly bypassing access controls such as firewalls that prevent the attackers from accessing the URLs directly. The server can be used as a proxy to conduct port scanning of hosts in internal networks, use other URLs such as that can access documents on the system (using file://), or use other protocols such as gopher:// or tftp://, which may provide greater control over the contents of requests.</desc>
          <test uuid="eb2e6c33-8703-490c-86c6-aa5aec532eee" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </weakness>
      </weaknesses>
      <countermeasures>
        <countermeasure uuid="cfcdf388-265f-431e-842b-6a6580d60a2e" ref="Detection_Methods" name="CWE-79 Detection Methods" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Automated Static Analysis // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible, especially when multiple components are involved. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate&lt;br&gt;&lt;strong&gt;METHOD&lt;/strong&gt;: Black Box // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use the XSS Cheat Sheet [REF-714] or automated test-generation tools to help launch a wide variety of attacks against your web application. The Cheat Sheet contains many subtle XSS variations that are specifically targeted against weak XSS defenses. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="7160a9e6-c87c-45dc-9694-47071ac8505f" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
        <countermeasure uuid="797dbe67-1e36-4deb-9f88-9aaa1775c4ea" ref="Potential_Mitigations" name="CWE-79 Potential Mitigations" platform="" cost="1" risk="0" state="Recommended" library="" source="MANUAL">
          <desc>&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Libraries or Frameworks // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Parts of the same output document may require different encodings, which will vary depending on whether the output is in the: HTML body Element attributes (such as src=XYZ) URIs JavaScript sections Cascading Style Sheets and style property etc. Note that HTML Entity Encoding is only appropriate for the HTML body. Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Attack Surface Reduction // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Limited&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Parameterization // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Output Encoding // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :With Struts, write all data from form beans with the bean's filter attribute set to true.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Attack Surface Reduction // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Defense in Depth&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Input Validation // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (&lt;3) would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the &lt; character, which would need to be escaped or otherwise handled. In this case, stripping the &lt; might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address. Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Architecture and Design // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Enforcement by Conversion // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Operation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Firewall // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth. // &lt;strong&gt;EFFECTIVENESS&lt;/strong&gt;: Moderate&lt;br&gt;&lt;strong&gt;PHASE&lt;/strong&gt; :Operation Implementation // &lt;strong&gt;STRATEGY&lt;/strong&gt;:Environment Hardening // &lt;strong&gt;DESCRIPTION&lt;/strong&gt;: :When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::</desc>
          <implementations/>
          <references/>
          <standards/>
          <customFields/>
          <test uuid="b6f31a37-8667-433b-bf72-4e30c660d16e" expiryDate="" expiryPeriod="0">
            <steps/>
            <notes/>
            <source filename="" args="" enabled="true">
              <output/>
            </source>
            <references/>
            <customFields/>
          </test>
        </countermeasure>
      </countermeasures>
      <usecases>
        <usecase uuid="0ffb2e2a-5343-4e91-af73-28e2cb07e4fb" ref="Elevation-of-Privilege" name="Elevation of Privilege" desc="" library="">
          <threats>
            <threat uuid="c2f22b61-fc9e-4b68-9a14-741da6a49e5a" ref="CSRF-Attacks" name="CWE-352 CSRF Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could trick authenticated users into unknowingly executing unauthorized actions on a web application, potentially leading to data manipulation, account takeover, or other malicious activities.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Non-Repudiation&lt;br&gt;SCOPE:Access Control // IMPACT:Gain Privileges or Assume Identity // IMPACT:Bypass Protection Mechanism // IMPACT:Read Application Data // IMPACT:Modify Application Data // IMPACT:DoS: Crash, Exit, or Restart // NOTE:The consequences will vary depending on the nature of the functionality that is vulnerable to CSRF. An attacker could effectively perform any operations as the victim. If the victim is an administrator or privileged user, the consequences may include obtaining complete control over the web application - deleting or stealing data, uninstalling the product, or using it to launch other attacks against all of the product's users. Because the attacker has the identity of the victim, the scope of CSRF is limited only by the victim's privileges.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-352">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
        <usecase uuid="3d7c9532-f7de-41c7-bfb8-9b9bb38aea0a" ref="Tampering" name="Tampering" desc="" library="">
          <threats>
            <threat uuid="27391451-058b-4ba5-a7bd-b60c52b60d99" ref="Cross-site-Scripting-(XSS)-Attacks" name="CWE-79 Cross-site Scripting (XSS) Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could inject malicious scripts into web pages viewed by other users, potentially stealing session cookies, redirecting users to malicious websites, or performing other malicious actions on behalf of the user.&lt;br&gt;&lt;br&gt;SCOPE:Access Control&lt;br&gt;SCOPE:Confidentiality // IMPACT:Bypass Protection Mechanism // IMPACT:Read Application Data // NOTE:The most common attack performed with cross-site scripting involves the disclosure of information stored in user cookies. Typically, a malicious user will craft a client-side script, which -- when parsed by a web browser -- performs some activity (such as sending all site cookies to a given E-mail address). This script will be loaded and run by each user visiting the web site. Since the site requesting to run the script has access to the cookies in question, the malicious script does also.&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Availability // IMPACT:Execute Unauthorized Code or Commands // NOTE:In some circumstances it may be possible to run arbitrary code on a victim's computer when cross-site scripting is combined with other flaws.&lt;br&gt;SCOPE:Confidentiality&lt;br&gt;SCOPE:Integrity&lt;br&gt;SCOPE:Availability&lt;br&gt;SCOPE:Access Control // IMPACT:Execute Unauthorized Code or Commands // IMPACT:Bypass Protection Mechanism // IMPACT:Read Application Data // NOTE:The consequence of an XSS attack is the same regardless of whether it is stored or reflected. The difference is in how the payload arrives at the server. XSS can cause a variety of problems for the end user that range in severity from an annoyance to complete account compromise. Some cross-site scripting vulnerabilities can be exploited to manipulate or steal cookies, create requests that can be mistaken for those of a valid user, compromise confidential information, or execute malicious code on the end user systems for a variety of nefarious purposes. Other damaging attacks include the disclosure of end user files, installation of Trojan horse programs, redirecting the user to some other page or site, running Active X controls (under Microsoft Internet Explorer) from sites that a user perceives as trustworthy, and modifying presentation of content.&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-79">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
            <threat uuid="65f19e2c-7c85-477d-83e2-695dfcff6d41" ref="SSRF-Attacks" name="CWE-918 SSRF Attacks" state="Expose" source="MANUAL" library="">
              <desc>Attackers could manipulate server-side requests to access internal systems, potentially leading to unauthorized data access, service disruption, or system compromise.&lt;br&gt;&lt;br&gt;SCOPE:Confidentiality // IMPACT:Read Application Data&lt;br&gt;SCOPE:Integrity // IMPACT:Execute Unauthorized Code or Commands&lt;br&gt;</desc>
              <riskRating confidentiality="75" integrity="75" availability="75" easeOfExploitation="25"/>
              <references/>
              <weaknesses>
                <weakness ref="CWE-918">
                  <countermeasures>
                    <countermeasure ref="Detection_Methods" mitigation="100"/>
                    <countermeasure ref="Potential_Mitigations" mitigation="100"/>
                  </countermeasures>
                </weakness>
              </weaknesses>
              <countermeasures>
                <countermeasure ref="Detection_Methods" mitigation="100"/>
                <countermeasure ref="Potential_Mitigations" mitigation="100"/>
              </countermeasures>
              <customFields/>
            </threat>
          </threats>
        </usecase>
      </usecases>
    </riskPattern>
  </riskPatterns>
  <rules/>
</library>
